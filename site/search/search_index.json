{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Generator Builder \u00b6 A small collection of generator-builder utilities and helpers for creating reusable Python generator components (for example, to drive PWM LEDs). This project evolved from the PWM example in the RPi-Pico repository. Overview \u00b6 What: A set of tiny classes that build generator factories (sequencers, repeaters, choosers, take-while helpers) that produce generators when called and a collection of float-valued generator factories such as sine, sawtooth, square, constant. Why: Make it easy to compose and reuse generator behavior across applications, with a MicroPython-friendly option by stripping type hints. By designing the Tester class, it is possible to write testers that communicate with other testers using a shared object. This could be used to program oscillations between the behaviors of collections of PWM-controlled LEDs. Key Features \u00b6 Generator Factories : Compose reusable generator patterns Wave Generators : Built-in sine, square, and sawtooth wave generators Flexible Control : Sequencing, repeating, random selection, and conditional testing MicroPython Compatible : Strip type hints for constrained environments Well Documented : Comprehensive docstrings and examples Quick Start \u00b6 from generator_builder import Constant , RepeaterFor , TakeWhile , CountTester from float_generator import sine_wave_factory # Create a sine wave that cycles 3 times sine = sine_wave_factory ( 16 , runs = 3 ) # Generate values for value in sine (): print ( round ( value , 2 )) Repository Structure \u00b6 File Purpose generator_builder.py Core generator-builder classes and examples float_generator.py Float-producing generator factories generator_builder_mp.py MicroPython-compatible version float_generator_mp.py MicroPython-compatible float generators strip_type_hints.py Utility to remove type hints pwm_leds/ PWM LED control examples License \u00b6 MIT License \u2014 see LICENSE for details.","title":"Home"},{"location":"#generator-builder","text":"A small collection of generator-builder utilities and helpers for creating reusable Python generator components (for example, to drive PWM LEDs). This project evolved from the PWM example in the RPi-Pico repository.","title":"Generator Builder"},{"location":"#overview","text":"What: A set of tiny classes that build generator factories (sequencers, repeaters, choosers, take-while helpers) that produce generators when called and a collection of float-valued generator factories such as sine, sawtooth, square, constant. Why: Make it easy to compose and reuse generator behavior across applications, with a MicroPython-friendly option by stripping type hints. By designing the Tester class, it is possible to write testers that communicate with other testers using a shared object. This could be used to program oscillations between the behaviors of collections of PWM-controlled LEDs.","title":"Overview"},{"location":"#key-features","text":"Generator Factories : Compose reusable generator patterns Wave Generators : Built-in sine, square, and sawtooth wave generators Flexible Control : Sequencing, repeating, random selection, and conditional testing MicroPython Compatible : Strip type hints for constrained environments Well Documented : Comprehensive docstrings and examples","title":"Key Features"},{"location":"#quick-start","text":"from generator_builder import Constant , RepeaterFor , TakeWhile , CountTester from float_generator import sine_wave_factory # Create a sine wave that cycles 3 times sine = sine_wave_factory ( 16 , runs = 3 ) # Generate values for value in sine (): print ( round ( value , 2 ))","title":"Quick Start"},{"location":"#repository-structure","text":"File Purpose generator_builder.py Core generator-builder classes and examples float_generator.py Float-producing generator factories generator_builder_mp.py MicroPython-compatible version float_generator_mp.py MicroPython-compatible float generators strip_type_hints.py Utility to remove type hints pwm_leds/ PWM LED control examples","title":"Repository Structure"},{"location":"#license","text":"MIT License \u2014 see LICENSE for details.","title":"License"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 We welcome contributions to the Generator Builder project! How to Contribute \u00b6 Reporting Issues \u00b6 Found a bug or have a suggestion? Please: Check existing issues to avoid duplicates Provide a clear description of the problem Include steps to reproduce (if applicable) Mention your Python version and environment Submitting Changes \u00b6 Fork the repository Create a branch for your changes Write tests for new features Update documentation as needed Submit a pull request with a clear description Development Setup \u00b6 # Clone the repository git clone https://github.com/pjritee/generator_builder.git cd generator_builder # Run tests python3 generator_builder.py python3 float_generator.py # Generate MicroPython versions python3 strip_type_hints.py generator_builder.py generator_builder_mp.py python3 strip_type_hints.py float_generator.py float_generator_mp.py Code Style \u00b6 Follow PEP 8 conventions Use meaningful variable names Add docstrings to public classes and methods Keep functions focused and composable Documentation \u00b6 Update docstrings when modifying behavior Add examples for new features Update API documentation in docs/api/ Keep the README and guides current Testing \u00b6 Test new features thoroughly Ensure MicroPython compatibility Test with the _mp.py versions Include both unit tests and integration examples License \u00b6 All contributions are under the MIT License. By submitting a pull request, you agree to license your contribution under the MIT License. Thank you for contributing! \ud83c\udf89","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"We welcome contributions to the Generator Builder project!","title":"Contributing"},{"location":"CONTRIBUTING/#how-to-contribute","text":"","title":"How to Contribute"},{"location":"CONTRIBUTING/#reporting-issues","text":"Found a bug or have a suggestion? Please: Check existing issues to avoid duplicates Provide a clear description of the problem Include steps to reproduce (if applicable) Mention your Python version and environment","title":"Reporting Issues"},{"location":"CONTRIBUTING/#submitting-changes","text":"Fork the repository Create a branch for your changes Write tests for new features Update documentation as needed Submit a pull request with a clear description","title":"Submitting Changes"},{"location":"CONTRIBUTING/#development-setup","text":"# Clone the repository git clone https://github.com/pjritee/generator_builder.git cd generator_builder # Run tests python3 generator_builder.py python3 float_generator.py # Generate MicroPython versions python3 strip_type_hints.py generator_builder.py generator_builder_mp.py python3 strip_type_hints.py float_generator.py float_generator_mp.py","title":"Development Setup"},{"location":"CONTRIBUTING/#code-style","text":"Follow PEP 8 conventions Use meaningful variable names Add docstrings to public classes and methods Keep functions focused and composable","title":"Code Style"},{"location":"CONTRIBUTING/#documentation","text":"Update docstrings when modifying behavior Add examples for new features Update API documentation in docs/api/ Keep the README and guides current","title":"Documentation"},{"location":"CONTRIBUTING/#testing","text":"Test new features thoroughly Ensure MicroPython compatibility Test with the _mp.py versions Include both unit tests and integration examples","title":"Testing"},{"location":"CONTRIBUTING/#license","text":"All contributions are under the MIT License. By submitting a pull request, you agree to license your contribution under the MIT License. Thank you for contributing! \ud83c\udf89","title":"License"},{"location":"LICENSE/","text":"MIT License \u00b6 Copyright (c) 2026 Peter Robinson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"LICENSE/#mit-license","text":"Copyright (c) 2026 Peter Robinson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"api/float_generator/","text":"Float Generator API \u00b6 Complete API reference for the float generator module. See float_generator.py for the source code and comprehensive docstrings. GeneratorFactoryFromFunctionform Functions \u00b6 These functions map [0, 1] to [0, 1] and are used by the GeneratorFactoryFromFunction class: sine_function(x) - Sine wave function square_wave_function(x) - Square wave function sawtooth_wave_function(x) - Sawtooth wave function Factory Functions \u00b6 Convenience functions to create GeneratorFactoryFromFunction generators with specific waveforms: sine_wave_factory(steps, offset=0.0, runs=1) - Create a sine wave generator square_wave_factory(steps, offset=0.0, runs=1) - Create a square wave generator sawtooth_wave_factory(steps, offset=0.0, runs=1) - Create a sawtooth wave generator Parameters \u00b6 steps : Integer number of steps per cycle, or tuple (min_steps, max_steps) for randomized counts offset : Phase offset in [0, 1], determining where in the cycle to start (default: 0.0) runs : Number of complete cycles. Use 0 for infinite cycles (default: 1) All classes and functions include comprehensive docstrings accessible via Python's help() function: from float_generator import sine_wave_factory help ( sine_wave_factory )","title":"Float Generator"},{"location":"api/float_generator/#float-generator-api","text":"Complete API reference for the float generator module. See float_generator.py for the source code and comprehensive docstrings.","title":"Float Generator API"},{"location":"api/float_generator/#generatorfactoryfromfunctionform-functions","text":"These functions map [0, 1] to [0, 1] and are used by the GeneratorFactoryFromFunction class: sine_function(x) - Sine wave function square_wave_function(x) - Square wave function sawtooth_wave_function(x) - Sawtooth wave function","title":"GeneratorFactoryFromFunctionform Functions"},{"location":"api/float_generator/#factory-functions","text":"Convenience functions to create GeneratorFactoryFromFunction generators with specific waveforms: sine_wave_factory(steps, offset=0.0, runs=1) - Create a sine wave generator square_wave_factory(steps, offset=0.0, runs=1) - Create a square wave generator sawtooth_wave_factory(steps, offset=0.0, runs=1) - Create a sawtooth wave generator","title":"Factory Functions"},{"location":"api/float_generator/#parameters","text":"steps : Integer number of steps per cycle, or tuple (min_steps, max_steps) for randomized counts offset : Phase offset in [0, 1], determining where in the cycle to start (default: 0.0) runs : Number of complete cycles. Use 0 for infinite cycles (default: 1) All classes and functions include comprehensive docstrings accessible via Python's help() function: from float_generator import sine_wave_factory help ( sine_wave_factory )","title":"Parameters"},{"location":"api/generator_builder/","text":"Generator Builder API \u00b6 Complete API reference for the generator builder module. See the source code generator_builder.py for comprehensive docstrings. Main Classes \u00b6 GeneratorFactory[T] - Base class for all generator factories Sequencer[T] - Chains multiple generators sequentially Chooser[T] - Randomly selects one generator RepeaterFor[T] - Repeats a generator a fixed number of times RandomRepeater[T] - Repeats a generator with specified probability Repeater[T] - Infinitely repeats a generator GeneratorFactoryFromFunction[T] - Generator factory derived from a function with configurable discretization and offset TakeWhile[T] - Yields values while a test condition is true Constant[T] - Yields a constant value infinitely ConstantFor[T] - Yields a constant value a specified number of times Tester Classes \u00b6 Tester - Base class for testers used with TakeWhile CountTester - Stops after a specified number of iterations TimeoutTester - Stops after a specified time duration All classes include comprehensive docstrings accessible via Python's help() function: from generator_builder import Sequencer help ( Sequencer )","title":"Generator Builder"},{"location":"api/generator_builder/#generator-builder-api","text":"Complete API reference for the generator builder module. See the source code generator_builder.py for comprehensive docstrings.","title":"Generator Builder API"},{"location":"api/generator_builder/#main-classes","text":"GeneratorFactory[T] - Base class for all generator factories Sequencer[T] - Chains multiple generators sequentially Chooser[T] - Randomly selects one generator RepeaterFor[T] - Repeats a generator a fixed number of times RandomRepeater[T] - Repeats a generator with specified probability Repeater[T] - Infinitely repeats a generator GeneratorFactoryFromFunction[T] - Generator factory derived from a function with configurable discretization and offset TakeWhile[T] - Yields values while a test condition is true Constant[T] - Yields a constant value infinitely ConstantFor[T] - Yields a constant value a specified number of times","title":"Main Classes"},{"location":"api/generator_builder/#tester-classes","text":"Tester - Base class for testers used with TakeWhile CountTester - Stops after a specified number of iterations TimeoutTester - Stops after a specified time duration All classes include comprehensive docstrings accessible via Python's help() function: from generator_builder import Sequencer help ( Sequencer )","title":"Tester Classes"},{"location":"api/generator_visualizer/","text":"Generator Visualizer \u00b6 Interactive TkInter application for visualizing generator output. Overview \u00b6 The Generator Visualizer provides a graphical user interface for testing and visualizing generators from the generator_builder and float_generator modules. It allows users to write Python code directly or load scripts that define generators, then see their output plotted on a canvas. Features \u00b6 Code Editor : Write or load Python code with a get_generator() function Visualization : Plot generator output on a canvas Interactive Controls : Run, stop, and clear graphs with button controls Configurable Max Points : Adjust the maximum number of points before generator terminates (10-1000) Configurable Every Nth point : Plot only every Nth point (1-100). Along with Max Points this determines how far through the generator the visualizer gets. Statistics Display : View point count, minimum, maximum, and average values File Loading : Load Python scripts with a get_generator() method Running the Visualizer \u00b6 python3 generator_visualizer.py This launches the interactive application with a two-panel layout: - Left Panel : Code editor with example code - Right Panel : Visualization canvas with controls Using the Visualizer \u00b6 Basic Usage \u00b6 Write Python code in the editor that defines a get_generator() function: from generator_builder import Constant , RepeaterFor def get_generator (): return RepeaterFor ( 3 , Constant ( 0.5 ))() Click Run to execute the generator and visualize output The result appears on the canvas with axes and gridlines Statistics display shows point count, min/max/average values Managing Scripts \u00b6 Click Load Script to browse and load a Python file that contains a get_generator() function. The file contents replace the editor code. Click Reload Script to reload the currently opened script from disk. This allows the user to user their editor of choice - make changes, save, reload into visualizer. Click Save Script to save the current script. Controls \u00b6 Run : Execute the generator code and visualize output Stop : Terminate a running generator Clear Graph : Clear the canvas and reset statistics Max Points : Spinbox to set the point limit (10-1000, default 500) Example Generators \u00b6 Sine Wave \u00b6 from generator_builder import GeneratorFactoryFromFunction import math def sine_function ( x ): return ( math . sin ( 2 * math . pi * x ) + 1 ) / 2 def get_generator (): gen_factory = GeneratorFactoryFromFunction ( sine_function , steps = 200 , runs = 2 ) return gen_factory () Sequence of Constants \u00b6 from generator_builder import Sequencer , ConstantFor def get_generator (): seq = Sequencer ([ ConstantFor ( 0.2 , 50 ), ConstantFor ( 0.5 , 50 ), ConstantFor ( 0.8 , 50 ), ]) return seq () Random Repeater \u00b6 from generator_builder import RandomRepeater , ConstantFor def get_generator (): return RandomRepeater ( 50 , ConstantFor ( 0.7 , 20 ))() Requirements \u00b6 Python 3.6+ tkinter (included with most Python installations) generator_builder and float_generator modules Class Reference \u00b6 GeneratorVisualizer \u00b6 Main application class managing the UI and generator execution. Attributes: generator : Currently loaded generator instance running : Boolean indicating if generator is executing current_values : List of plotted values max_points : Maximum points before generator terminates (default: 500) Methods: _run_generator() : Execute generator from code editor _stop_generator() : Terminate running generator _clear_graph() : Clear visualization and statistics _load_script() : Load Python script from file _redraw_canvas() : Update visualization with current data _update_max_points() : Update max_points from spinbox Graph Display \u00b6 The visualization canvas includes: Axes : X-axis for index, Y-axis for values Gridlines : Horizontal lines at regular intervals for reference Data Points : Blue dots at each value Connecting Lines : Blue line connecting all points to show waveform Labels : Min/max value labels on Y-axis The graph automatically scales to fit all data points and adjusts when the window is resized. Error Handling \u00b6 Missing Function : Returns error if code doesn't define get_generator() Execution Errors : Displays error message if generator raises an exception Invalid Values : Silently skips non-numeric values from generator File Load Errors : Shows dialog if script cannot be loaded All errors are displayed as messagebox dialogs and logged to the status label.","title":"Generator Visualizer"},{"location":"api/generator_visualizer/#generator-visualizer","text":"Interactive TkInter application for visualizing generator output.","title":"Generator Visualizer"},{"location":"api/generator_visualizer/#overview","text":"The Generator Visualizer provides a graphical user interface for testing and visualizing generators from the generator_builder and float_generator modules. It allows users to write Python code directly or load scripts that define generators, then see their output plotted on a canvas.","title":"Overview"},{"location":"api/generator_visualizer/#features","text":"Code Editor : Write or load Python code with a get_generator() function Visualization : Plot generator output on a canvas Interactive Controls : Run, stop, and clear graphs with button controls Configurable Max Points : Adjust the maximum number of points before generator terminates (10-1000) Configurable Every Nth point : Plot only every Nth point (1-100). Along with Max Points this determines how far through the generator the visualizer gets. Statistics Display : View point count, minimum, maximum, and average values File Loading : Load Python scripts with a get_generator() method","title":"Features"},{"location":"api/generator_visualizer/#running-the-visualizer","text":"python3 generator_visualizer.py This launches the interactive application with a two-panel layout: - Left Panel : Code editor with example code - Right Panel : Visualization canvas with controls","title":"Running the Visualizer"},{"location":"api/generator_visualizer/#using-the-visualizer","text":"","title":"Using the Visualizer"},{"location":"api/generator_visualizer/#basic-usage","text":"Write Python code in the editor that defines a get_generator() function: from generator_builder import Constant , RepeaterFor def get_generator (): return RepeaterFor ( 3 , Constant ( 0.5 ))() Click Run to execute the generator and visualize output The result appears on the canvas with axes and gridlines Statistics display shows point count, min/max/average values","title":"Basic Usage"},{"location":"api/generator_visualizer/#managing-scripts","text":"Click Load Script to browse and load a Python file that contains a get_generator() function. The file contents replace the editor code. Click Reload Script to reload the currently opened script from disk. This allows the user to user their editor of choice - make changes, save, reload into visualizer. Click Save Script to save the current script.","title":"Managing Scripts"},{"location":"api/generator_visualizer/#controls","text":"Run : Execute the generator code and visualize output Stop : Terminate a running generator Clear Graph : Clear the canvas and reset statistics Max Points : Spinbox to set the point limit (10-1000, default 500)","title":"Controls"},{"location":"api/generator_visualizer/#example-generators","text":"","title":"Example Generators"},{"location":"api/generator_visualizer/#sine-wave","text":"from generator_builder import GeneratorFactoryFromFunction import math def sine_function ( x ): return ( math . sin ( 2 * math . pi * x ) + 1 ) / 2 def get_generator (): gen_factory = GeneratorFactoryFromFunction ( sine_function , steps = 200 , runs = 2 ) return gen_factory ()","title":"Sine Wave"},{"location":"api/generator_visualizer/#sequence-of-constants","text":"from generator_builder import Sequencer , ConstantFor def get_generator (): seq = Sequencer ([ ConstantFor ( 0.2 , 50 ), ConstantFor ( 0.5 , 50 ), ConstantFor ( 0.8 , 50 ), ]) return seq ()","title":"Sequence of Constants"},{"location":"api/generator_visualizer/#random-repeater","text":"from generator_builder import RandomRepeater , ConstantFor def get_generator (): return RandomRepeater ( 50 , ConstantFor ( 0.7 , 20 ))()","title":"Random Repeater"},{"location":"api/generator_visualizer/#requirements","text":"Python 3.6+ tkinter (included with most Python installations) generator_builder and float_generator modules","title":"Requirements"},{"location":"api/generator_visualizer/#class-reference","text":"","title":"Class Reference"},{"location":"api/generator_visualizer/#generatorvisualizer","text":"Main application class managing the UI and generator execution. Attributes: generator : Currently loaded generator instance running : Boolean indicating if generator is executing current_values : List of plotted values max_points : Maximum points before generator terminates (default: 500) Methods: _run_generator() : Execute generator from code editor _stop_generator() : Terminate running generator _clear_graph() : Clear visualization and statistics _load_script() : Load Python script from file _redraw_canvas() : Update visualization with current data _update_max_points() : Update max_points from spinbox","title":"GeneratorVisualizer"},{"location":"api/generator_visualizer/#graph-display","text":"The visualization canvas includes: Axes : X-axis for index, Y-axis for values Gridlines : Horizontal lines at regular intervals for reference Data Points : Blue dots at each value Connecting Lines : Blue line connecting all points to show waveform Labels : Min/max value labels on Y-axis The graph automatically scales to fit all data points and adjusts when the window is resized.","title":"Graph Display"},{"location":"api/generator_visualizer/#error-handling","text":"Missing Function : Returns error if code doesn't define get_generator() Execution Errors : Displays error message if generator raises an exception Invalid Values : Silently skips non-numeric values from generator File Load Errors : Shows dialog if script cannot be loaded All errors are displayed as messagebox dialogs and logged to the status label.","title":"Error Handling"},{"location":"guide/concepts/","text":"Core Concepts \u00b6 Generator Factories \u00b6 A GeneratorFactory is the central concept in this library. It's a callable class that produces fresh generators each time it's called. Why Use Factories? \u00b6 When you call a generator factory multiple times, you get independent generator instances: factory = Constant ( 42 ) gen1 = factory () gen2 = factory () # Both generators are fresh and independent print ( next ( gen1 )) # 42 print ( next ( gen2 )) # 42 print ( next ( gen1 )) # 42 This design allows you to: Reuse factories across different contexts Create generator pipelines Compose complex behaviors from simple building blocks Higher-Order Factories \u00b6 Many classes are higher-order \u2014 they take generator factories as parameters and return new factories that combine them: from generator_builder import ConstantFor , RepeaterFor , Sequencer const = ConstantFor ( 1 , 2 ) # Higher-order factory that repeatedly yields from const # This is a simple illustration - it could be more simply written as ConstantFor(1, 6) repeated = RepeaterFor ( 3 , const ) list ( repeated ()) # [1, 1, 1, 1, 1, 1] Common Patterns \u00b6 Sequential Composition \u00b6 Chain multiple generators: from generator_builder import Sequencer , ConstantFor seq = Sequencer ([ ConstantFor ( 1 , 1 ), ConstantFor ( 2 , 2 ), ConstantFor ( 3 , 3 ) ]) print ( list ( seq ())) #[1, 2, 2, 3, 3, 3] Repetition \u00b6 Repeat a finite generator: from generator_builder import RepeaterFor , ConstantFor # Yields 5 twice factory = RepeaterFor ( 2 , ConstantFor ( 5 , 1 )) list ( factory ()) # [5, 5] Conditional Execution \u00b6 Use testers to control generator lifetime: from generator_builder import TakeWhile , CountTester , Constant tester = CountTester ( 3 ) factory = TakeWhile ( tester , Constant ( 1 )) list ( factory ()) # [1,1,1] Random Selection \u00b6 Randomly choose from multiple generators: from generator_builder import Chooser , ConstantFor factory = Chooser ([ ConstantFor ( 1 , 1 ), ConstantFor ( 2 , 2 ), ConstantFor ( 3 , 3 ) ]) # Result is one of the three, chosen randomly list ( factory ()) # one of [1] [2,2] [3,3,3] Testers \u00b6 Testers determine when a generator should stop producing values. They're used with TakeWhile : from generator_builder import TakeWhile , TimeoutTester , Constant # Stop after 0.1 second tester = TimeoutTester ( 0.1 ) factory = TakeWhile ( tester , Constant ( 1 )) # Yields 1 for approximately 0.1 seconds Custom Testers \u00b6 Implement custom test conditions: from generator_builder import Tester , TakeWhile class Flag : \"\"\"Create a flag object\"\"\" def __init__ ( self ): self . flag = False def set_flag ( self ): self . flag = True class FlagTester ( Tester ): def __init__ ( self , flagobj ): self . flagobj = flagobj def __call__ ( self ): def test (): return not self . flagobj . flag return test # When used as a tester in TakeWhile the generator will terminate when the flag is set # by some other generator or process Wave forms \u00b6 Float generators produce smooth varying values useful for PWM control: from float_generator import sine_wave_factory # Create a sine wave sine = sine_wave_factory ( 100 ) # 100 steps per cycle # Values oscillate between 0 and 1 for value in sine (): print ( f \"PWM duty cycle: { value * 100 : .1f } %\" ) Available wave forms \u00b6 Sine : Smooth oscillation Square : Digital on/off Sawtooth : Linear ramps All support: Custom step counts Random step ranges Phase offset Multiple cycles or infinite repetition Design Philosophy \u00b6 The library emphasizes: Composability : Chain and nest factories to create complex behaviors Reusability : Factories can be used multiple times and in different contexts Simplicity : Each class has a single, clear responsibility Flexibility : Use with any value type through generics","title":"Core Concepts"},{"location":"guide/concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"guide/concepts/#generator-factories","text":"A GeneratorFactory is the central concept in this library. It's a callable class that produces fresh generators each time it's called.","title":"Generator Factories"},{"location":"guide/concepts/#why-use-factories","text":"When you call a generator factory multiple times, you get independent generator instances: factory = Constant ( 42 ) gen1 = factory () gen2 = factory () # Both generators are fresh and independent print ( next ( gen1 )) # 42 print ( next ( gen2 )) # 42 print ( next ( gen1 )) # 42 This design allows you to: Reuse factories across different contexts Create generator pipelines Compose complex behaviors from simple building blocks","title":"Why Use Factories?"},{"location":"guide/concepts/#higher-order-factories","text":"Many classes are higher-order \u2014 they take generator factories as parameters and return new factories that combine them: from generator_builder import ConstantFor , RepeaterFor , Sequencer const = ConstantFor ( 1 , 2 ) # Higher-order factory that repeatedly yields from const # This is a simple illustration - it could be more simply written as ConstantFor(1, 6) repeated = RepeaterFor ( 3 , const ) list ( repeated ()) # [1, 1, 1, 1, 1, 1]","title":"Higher-Order Factories"},{"location":"guide/concepts/#common-patterns","text":"","title":"Common Patterns"},{"location":"guide/concepts/#sequential-composition","text":"Chain multiple generators: from generator_builder import Sequencer , ConstantFor seq = Sequencer ([ ConstantFor ( 1 , 1 ), ConstantFor ( 2 , 2 ), ConstantFor ( 3 , 3 ) ]) print ( list ( seq ())) #[1, 2, 2, 3, 3, 3]","title":"Sequential Composition"},{"location":"guide/concepts/#repetition","text":"Repeat a finite generator: from generator_builder import RepeaterFor , ConstantFor # Yields 5 twice factory = RepeaterFor ( 2 , ConstantFor ( 5 , 1 )) list ( factory ()) # [5, 5]","title":"Repetition"},{"location":"guide/concepts/#conditional-execution","text":"Use testers to control generator lifetime: from generator_builder import TakeWhile , CountTester , Constant tester = CountTester ( 3 ) factory = TakeWhile ( tester , Constant ( 1 )) list ( factory ()) # [1,1,1]","title":"Conditional Execution"},{"location":"guide/concepts/#random-selection","text":"Randomly choose from multiple generators: from generator_builder import Chooser , ConstantFor factory = Chooser ([ ConstantFor ( 1 , 1 ), ConstantFor ( 2 , 2 ), ConstantFor ( 3 , 3 ) ]) # Result is one of the three, chosen randomly list ( factory ()) # one of [1] [2,2] [3,3,3]","title":"Random Selection"},{"location":"guide/concepts/#testers","text":"Testers determine when a generator should stop producing values. They're used with TakeWhile : from generator_builder import TakeWhile , TimeoutTester , Constant # Stop after 0.1 second tester = TimeoutTester ( 0.1 ) factory = TakeWhile ( tester , Constant ( 1 )) # Yields 1 for approximately 0.1 seconds","title":"Testers"},{"location":"guide/concepts/#custom-testers","text":"Implement custom test conditions: from generator_builder import Tester , TakeWhile class Flag : \"\"\"Create a flag object\"\"\" def __init__ ( self ): self . flag = False def set_flag ( self ): self . flag = True class FlagTester ( Tester ): def __init__ ( self , flagobj ): self . flagobj = flagobj def __call__ ( self ): def test (): return not self . flagobj . flag return test # When used as a tester in TakeWhile the generator will terminate when the flag is set # by some other generator or process","title":"Custom Testers"},{"location":"guide/concepts/#wave-forms","text":"Float generators produce smooth varying values useful for PWM control: from float_generator import sine_wave_factory # Create a sine wave sine = sine_wave_factory ( 100 ) # 100 steps per cycle # Values oscillate between 0 and 1 for value in sine (): print ( f \"PWM duty cycle: { value * 100 : .1f } %\" )","title":"Wave forms"},{"location":"guide/concepts/#available-wave-forms","text":"Sine : Smooth oscillation Square : Digital on/off Sawtooth : Linear ramps All support: Custom step counts Random step ranges Phase offset Multiple cycles or infinite repetition","title":"Available wave forms"},{"location":"guide/concepts/#design-philosophy","text":"The library emphasizes: Composability : Chain and nest factories to create complex behaviors Reusability : Factories can be used multiple times and in different contexts Simplicity : Each class has a single, clear responsibility Flexibility : Use with any value type through generics","title":"Design Philosophy"},{"location":"guide/examples/","text":"Usage Examples \u00b6 LED Brightness Control \u00b6 Smoothly fade a LED up and down: from float_generator import sine_wave_factory from generator_builder import Repeater # Create infinite sine wave cycles sine = sine_wave_factory ( 50 , runs = 0 ) for brightness in sine (): # runs indefinitely set_pwm_duty ( brightness ) # 0.0 to 1.0 time . sleep ( 0.01 ) Multiple LEDs with Different Patterns \u00b6 Control multiple LEDs with different waveforms: from float_generator import sine_wave_factory , square_wave_factory from generator_builder import Repeater # LED 1: smooth sine wave sine = sine_wave_factory ( 50 , runs = 0 ) # LED 2: square wave blink square = square_wave_factory ( 20 , runs = 0 ) leds_control = [( led1 , sine ()), ( leds2 , square ())] while True : for led , gen in leds_control : led . set_brightness ( next ( gen )) time . sleep ( 0.01 ) Time-Limited Sequences \u00b6 Create sequences that stop after a timeout: from generator_builder import ( Sequencer , TakeWhile , TimeoutTester , ConstantFor ) from float_generator import sine_wave_factory # Run for 5 seconds max tester = TimeoutTester ( 5.0 ) sequence = TakeWhile ( tester , Repeater ( Sequencer ([ sine_wave_factory ( 20 ), # one cycle of sine ConstantFor ( 0.5 , 50 ), # Hold at 50% brightness ConstantFor ( 0.0 , 50 ), # Turn off ])) ) for value in sequence (): set_pwm_duty ( value ) Random Pattern Selection \u00b6 Alternate between patterns randomly: from generator_builder import ( Repeater , Chooser , TakeWhile , CountTester ) from float_generator import ( sine_wave_factory , square_wave_factory , sawtooth_wave_factory ) # Create multiple pattern factories patterns = Chooser ([ sine_wave_factory ( 50 , runs = 10 ), square_wave_factory ( 20 , runs = 10 ), sawtooth_wave_factory ( 30 , runs = 10 ), ]) # Run 3 random selections test = CountTester ( 300 ) # Adjust based on expected steps sequence = TakeWhile ( test , Repeater ( patterns )) for value in sequence (): set_pwm_duty ( value ) Pulse Train with Random Duration \u00b6 Create pulses with random lengths: from generator_builder import ( RandomRepeater , ConstantFor , Sequencer ) # One pulse: high then low pulse = Sequencer ([ ConstantFor ( 1.0 , 20 ), # High for 20 steps ConstantFor ( 0.0 , 20 ), # Low for 20 steps ]) # Repeat randomly with 75% probability train = RandomRepeater ( 75 , pulse ) for value in train (): set_pwm_duty ( value ) MicroPython Example \u00b6 Control PWM LEDs on Raspberry Pi Pico: from machine import Pin , PWM import generator_builder_mp as gb import float_generator_mp as fg # Setup PWM led = PWM ( Pin ( 15 )) led . freq ( 1000 ) # 1 kHz # Create pattern sine = fg . sine_wave_factory ( 100 ) # Generate and apply for brightness in sine (): duty = int ( brightness * 65535 ) led . duty_u16 ( duty ) Synchronized Multi-LED Control \u00b6 Offset different LEDs for visual effect: from float_generator_mp import sine_wave_factory from generator_builder_mp import Repeater led_configs = [ ( led1 , 0.0 ), # Start at 0 ( led2 , 0.33 ), # Start at 1/3 through ( led3 , 0.66 ), # Start at 2/3 through ] generators = [ ( led , sine_wave_factory ( 100 , runs = 0 , offset = offset )()) for led , offset in led_configs ] # Run while True : for led , gen in generators : set_pwm ( led , next ( gen )) time . sleep ( 0.01 ) Breathing LED Effect \u00b6 Classic \"breathing\" effect using sine wave: from float_generator_mp import sine_wave_factory from generator_builder_mp import Repeater import time # Slow sine wave for breathing breathing = sine_wave_factory ( 200 , runs = 0 ) min_brightness = 0.1 max_brightness = 1.0 for normalized_value in breathing (): # Scale to min/max range brightness = min_brightness + normalized_value * ( max_brightness - min_brightness ) set_pwm_duty ( brightness ) time . sleep ( 4 ) # 4 second breathing cycle","title":"Usage Examples"},{"location":"guide/examples/#usage-examples","text":"","title":"Usage Examples"},{"location":"guide/examples/#led-brightness-control","text":"Smoothly fade a LED up and down: from float_generator import sine_wave_factory from generator_builder import Repeater # Create infinite sine wave cycles sine = sine_wave_factory ( 50 , runs = 0 ) for brightness in sine (): # runs indefinitely set_pwm_duty ( brightness ) # 0.0 to 1.0 time . sleep ( 0.01 )","title":"LED Brightness Control"},{"location":"guide/examples/#multiple-leds-with-different-patterns","text":"Control multiple LEDs with different waveforms: from float_generator import sine_wave_factory , square_wave_factory from generator_builder import Repeater # LED 1: smooth sine wave sine = sine_wave_factory ( 50 , runs = 0 ) # LED 2: square wave blink square = square_wave_factory ( 20 , runs = 0 ) leds_control = [( led1 , sine ()), ( leds2 , square ())] while True : for led , gen in leds_control : led . set_brightness ( next ( gen )) time . sleep ( 0.01 )","title":"Multiple LEDs with Different Patterns"},{"location":"guide/examples/#time-limited-sequences","text":"Create sequences that stop after a timeout: from generator_builder import ( Sequencer , TakeWhile , TimeoutTester , ConstantFor ) from float_generator import sine_wave_factory # Run for 5 seconds max tester = TimeoutTester ( 5.0 ) sequence = TakeWhile ( tester , Repeater ( Sequencer ([ sine_wave_factory ( 20 ), # one cycle of sine ConstantFor ( 0.5 , 50 ), # Hold at 50% brightness ConstantFor ( 0.0 , 50 ), # Turn off ])) ) for value in sequence (): set_pwm_duty ( value )","title":"Time-Limited Sequences"},{"location":"guide/examples/#random-pattern-selection","text":"Alternate between patterns randomly: from generator_builder import ( Repeater , Chooser , TakeWhile , CountTester ) from float_generator import ( sine_wave_factory , square_wave_factory , sawtooth_wave_factory ) # Create multiple pattern factories patterns = Chooser ([ sine_wave_factory ( 50 , runs = 10 ), square_wave_factory ( 20 , runs = 10 ), sawtooth_wave_factory ( 30 , runs = 10 ), ]) # Run 3 random selections test = CountTester ( 300 ) # Adjust based on expected steps sequence = TakeWhile ( test , Repeater ( patterns )) for value in sequence (): set_pwm_duty ( value )","title":"Random Pattern Selection"},{"location":"guide/examples/#pulse-train-with-random-duration","text":"Create pulses with random lengths: from generator_builder import ( RandomRepeater , ConstantFor , Sequencer ) # One pulse: high then low pulse = Sequencer ([ ConstantFor ( 1.0 , 20 ), # High for 20 steps ConstantFor ( 0.0 , 20 ), # Low for 20 steps ]) # Repeat randomly with 75% probability train = RandomRepeater ( 75 , pulse ) for value in train (): set_pwm_duty ( value )","title":"Pulse Train with Random Duration"},{"location":"guide/examples/#micropython-example","text":"Control PWM LEDs on Raspberry Pi Pico: from machine import Pin , PWM import generator_builder_mp as gb import float_generator_mp as fg # Setup PWM led = PWM ( Pin ( 15 )) led . freq ( 1000 ) # 1 kHz # Create pattern sine = fg . sine_wave_factory ( 100 ) # Generate and apply for brightness in sine (): duty = int ( brightness * 65535 ) led . duty_u16 ( duty )","title":"MicroPython Example"},{"location":"guide/examples/#synchronized-multi-led-control","text":"Offset different LEDs for visual effect: from float_generator_mp import sine_wave_factory from generator_builder_mp import Repeater led_configs = [ ( led1 , 0.0 ), # Start at 0 ( led2 , 0.33 ), # Start at 1/3 through ( led3 , 0.66 ), # Start at 2/3 through ] generators = [ ( led , sine_wave_factory ( 100 , runs = 0 , offset = offset )()) for led , offset in led_configs ] # Run while True : for led , gen in generators : set_pwm ( led , next ( gen )) time . sleep ( 0.01 )","title":"Synchronized Multi-LED Control"},{"location":"guide/examples/#breathing-led-effect","text":"Classic \"breathing\" effect using sine wave: from float_generator_mp import sine_wave_factory from generator_builder_mp import Repeater import time # Slow sine wave for breathing breathing = sine_wave_factory ( 200 , runs = 0 ) min_brightness = 0.1 max_brightness = 1.0 for normalized_value in breathing (): # Scale to min/max range brightness = min_brightness + normalized_value * ( max_brightness - min_brightness ) set_pwm_duty ( brightness ) time . sleep ( 4 ) # 4 second breathing cycle","title":"Breathing LED Effect"},{"location":"guide/getting_started/","text":"Getting Started \u00b6 Installation \u00b6 Generator Builder is a pure Python module. To use it in your project: Standard Python \u00b6 # Copy the files to your project cp generator_builder.py your_project/ cp float_generator.py your_project/ MicroPython \u00b6 For use on Raspberry Pi Pico or other MicroPython environments: # Generate MicroPython-compatible versions python3 strip_type_hints.py generator_builder.py generator_builder_mp.py python3 strip_type_hints.py float_generator.py float_generator_mp.py # Copy the _mp.py files to your device Running Tests \u00b6 Generator Builder Tests \u00b6 python3 generator_builder.py This runs comprehensive tests of all generator factory classes and demonstrates their usage. Float Generator Tests \u00b6 python3 float_generator.py This tests all waveform generators and validates output ranges. Basic Concepts \u00b6 Generator Factories \u00b6 A GeneratorFactory is a callable object that creates fresh generators: from generator_builder import ConstantFor # Create a factory factory = ConstantFor ( 42 , 2 ) # Each call produces a fresh generator gen1 = factory () gen2 = factory () # They are independent instances print ( list ( gen1 )) # [42, 42] print ( list ( gen2 )) # [42, 42] Composing Generators \u00b6 Combine multiple factories to create complex behaviors: from generator_builder import ConstantFor , RepeaterFor , Sequencer # Create individual factories gen1 = ConstantFor ( 1 , 3 ) gen2 = ConstantFor ( 2 , 2 ) # Combine them seq = Sequencer ([ gen1 , gen2 ]) # Run print ( list ( seq ())) # [1, 1, 1, 2, 2] Wave forms \u00b6 Use built-in waveform generators to produce values from the waveform: from float_generator import sine_wave_factory # Create a sine wave with 16 steps per cycle sine = sine_wave_factory ( 16 ) # Generate values in [0, 1] for value in sine (): print ( f \"Value: { value : .2f } \" ) Next Steps \u00b6 Read the Core Concepts guide for detailed explanations Explore Usage Examples for practical patterns Check the API Reference for complete documentation","title":"Getting Started"},{"location":"guide/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"guide/getting_started/#installation","text":"Generator Builder is a pure Python module. To use it in your project:","title":"Installation"},{"location":"guide/getting_started/#standard-python","text":"# Copy the files to your project cp generator_builder.py your_project/ cp float_generator.py your_project/","title":"Standard Python"},{"location":"guide/getting_started/#micropython","text":"For use on Raspberry Pi Pico or other MicroPython environments: # Generate MicroPython-compatible versions python3 strip_type_hints.py generator_builder.py generator_builder_mp.py python3 strip_type_hints.py float_generator.py float_generator_mp.py # Copy the _mp.py files to your device","title":"MicroPython"},{"location":"guide/getting_started/#running-tests","text":"","title":"Running Tests"},{"location":"guide/getting_started/#generator-builder-tests","text":"python3 generator_builder.py This runs comprehensive tests of all generator factory classes and demonstrates their usage.","title":"Generator Builder Tests"},{"location":"guide/getting_started/#float-generator-tests","text":"python3 float_generator.py This tests all waveform generators and validates output ranges.","title":"Float Generator Tests"},{"location":"guide/getting_started/#basic-concepts","text":"","title":"Basic Concepts"},{"location":"guide/getting_started/#generator-factories","text":"A GeneratorFactory is a callable object that creates fresh generators: from generator_builder import ConstantFor # Create a factory factory = ConstantFor ( 42 , 2 ) # Each call produces a fresh generator gen1 = factory () gen2 = factory () # They are independent instances print ( list ( gen1 )) # [42, 42] print ( list ( gen2 )) # [42, 42]","title":"Generator Factories"},{"location":"guide/getting_started/#composing-generators","text":"Combine multiple factories to create complex behaviors: from generator_builder import ConstantFor , RepeaterFor , Sequencer # Create individual factories gen1 = ConstantFor ( 1 , 3 ) gen2 = ConstantFor ( 2 , 2 ) # Combine them seq = Sequencer ([ gen1 , gen2 ]) # Run print ( list ( seq ())) # [1, 1, 1, 2, 2]","title":"Composing Generators"},{"location":"guide/getting_started/#wave-forms","text":"Use built-in waveform generators to produce values from the waveform: from float_generator import sine_wave_factory # Create a sine wave with 16 steps per cycle sine = sine_wave_factory ( 16 ) # Generate values in [0, 1] for value in sine (): print ( f \"Value: { value : .2f } \" )","title":"Wave forms"},{"location":"guide/getting_started/#next-steps","text":"Read the Core Concepts guide for detailed explanations Explore Usage Examples for practical patterns Check the API Reference for complete documentation","title":"Next Steps"}]}